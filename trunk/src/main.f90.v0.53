program antares
use common_params
implicit none
include 'mpif.h'
include 'fftw_f77.i'

character(len=8)::infile='para.nml' ! filename of namelist
character(len=8)::flnm
character(len=20)::dsetname
integer::ierr ! error flag for MPI
double precision::dt_loc,toutput ! local time step, next point for data output
integer::fnum=0,fstart! number of file number
integer::i,j,k

#if NDIM==2
double precision,dimension(:,:,:),allocatable::q_loc,temp1_loc,temp2_loc

#ifdef MHD
double precision,dimension(:,:,:),allocatable::temp3_loc
#endif

#ifdef FORCE
double precision,dimension(:,:),allocatable::fx,fy  ! external force
#endif

#ifdef GRAVITY
double precision,dimension(:,:),allocatable::den 
#endif
#endif

#if NDIM==3
double precision,dimension(:,:,:,:),allocatable::q_loc,temp1_loc,temp2_loc

#ifdef FORCE
double precision,dimension(:,:,:),allocatable::fx,fy,fz
#endif

#ifdef GRAVITY
double precision,dimension(:,:,:),allocatable::den 
#endif
#endif




namelist/run_params/ncell,xrange,yrange,zrange, &
                    tend,CFL,&
                    dtout,snd,gam,GravConst,&
                    fstart

call MPI_INIT(ierr)
call MPI_COMM_SIZE(MPI_COMM_WORLD,nprocs,ierr)
call MPI_COMM_RANK(MPI_COMM_WORLD,myid,ierr)

#ifdef VERBOSE
write(*,'("node",I2,"/",I2,"   ready!!")') myid+1,nprocs
#endif

call MPI_BARRIER(MPI_COMM_WORLD, ierr)
open(1,file=infile)
read(1,NML=run_params)
close(1)

#ifdef VERBOSE
if(myid .eq. 0) then
  write(*,*) "NDIM: ",NDIM
  write(*,*) "ncell: ",ncell
  write(*,*) "xrange: ",xrange
  write(*,*) "yrange: ",yrange
  write(*,*) "zrange: ",zrange
  write(*,*) "tend: ",tend
  write(*,*) "CFL: ",CFL
  write(*,*) "dtout: ",dtout
  write(*,*) "snd: ",snd
  write(*,*) "gam: ",gam
  write(*,*) "fstart: ",fstart
#ifdef GRAVITY
  write(*,*) "GravConst: ",GravConst
#endif
endif
#endif
call MPI_BARRIER(MPI_COMM_WORLD, ierr)

#if NDIM==2

ncell_loc(1) = ncell(1)
ncell_loc(2) = ncell(2)/nprocs
ncell_loc(3) = 0
allocate(x_loc(1-ibuf:ncell_loc(1)+ibuf))
allocate(y_loc(1-jbuf:ncell_loc(2)+jbuf))
allocate(x(1-ibuf:ncell(1)+ibuf))
allocate(y(1-jbuf:ncell(2)+jbuf))
allocate(q_loc(1-ibuf:ncell_loc(1)+ibuf,1-jbuf:ncell_loc(2)+jbuf,NVAR))
allocate(temp1_loc(1-ibuf:ncell_loc(1)+ibuf,1-jbuf:ncell_loc(2)+jbuf,NVAR))
allocate(temp2_loc(1-ibuf:ncell_loc(1)+ibuf,1-jbuf:ncell_loc(2)+jbuf,NVAR))
#ifdef MHD
allocate(temp3_loc(1-ibuf:ncell_loc(1)+ibuf,1-jbuf:ncell_loc(2)+jbuf,NVAR))
#endif

#ifdef FORCE
allocate(fx(1:ncell_loc(1),1:ncell_loc(2)))
allocate(fy(1:ncell_loc(1),1:ncell_loc(2)))
#endif

#ifdef GRAVITY
allocate(den(1:ncell_loc(1),1:ncell_loc(2)))
allocate(sgx(1:ncell_loc(1),1:ncell_loc(2)))
allocate(sgy(1:ncell_loc(1),1:ncell_loc(2)))
allocate(sgxker(1:2*ncell_loc(1),1:2*ncell_loc(2)))
allocate(sgyker(1:2*ncell_loc(1),1:2*ncell_loc(2)))
#endif

dx = (xrange(2)-xrange(1))/dble(ncell(1))
dy = (yrange(2)-yrange(1))/dble(ncell(2))

do i = 1-ibuf, ncell_loc(1)+ibuf
    x_loc(i) = xrange(1)+(dble(i)-0.5d0)*dx
enddo

do i = 1-jbuf, ncell_loc(2)+jbuf
    y_loc(i) = yrange(1)+(dble(i)-0.5d0+dble(myid*ncell_loc(2)))*dy
enddo

do i=1-ibuf, ncell(1)+ibuf
   x(i) = xrange(1)+(dble(i)-0.5d0)*dx
enddo

do i=1-jbuf, ncell(2)+jbuf
   y(i) = yrange(1)+(dble(i)-0.5d0)*dy
enddo

if(fstart .eq. 0) then
  t = 0.d0
  call init2d(q_loc)  !! fresh start
  call bdry2d(q_loc)
  if(nprocs .gt. 1) then
    call sendbdry2d(q_loc)
  endif
  call write_collective2d(q_loc,fnum)
#ifdef GRAVITY
  call sgkernel2d() !!prepare the complex kernel FFT
  if(myid .eq. 0) then
  write(*,*) "calculating self-gravity for the initial condition......"
  endif
  den=q_loc(1:ncell_loc(1),1:ncell_loc(2),1)
  call selfgravity2d(den)  !!real force of selfgravity
  if(myid .eq. 0) then
    write(*,*) "done"
    write(*,*) "writing initial selfgravity into files......"
  endif
  call write_gravity2d(fnum)
  if(myid .eq. 0) then
    write(*,*) "done."
    write(*,*) "start main loop......"
  endif
#endif
else   ! not fresh start
  write(*,*) "loading ...."
  call read_collective2d(q_loc,fstart) !!read data from fstart
  if(nprocs .gt. 1) then
     call sendbdry2d(q_loc)
  endif
#ifdef GRAVITY
  call sgkernel2d() !!prepare the complex kernel FFT
#endif
  fnum = fstart
endif

call dt_loc2d(q_loc,dt_loc)
call dt_all(dt_loc)
toutput=t+dtout

!!!! main loop
do while(t .lt. tend)
t=t+dt
if(myid .eq. 0) then
   write(*,*) "(t,dt)=",t,dt
endif
! RK1
call riemann2d(q_loc,q_loc,temp1_loc,1)  ! 1: x
call riemann2d(q_loc,temp1_loc,temp1_loc,2) ! 2: y

#ifdef FORCE
  call force2d(q_loc,fx,fy)  ! external force
  do j=1,ncell_loc(2)
    do i=1,ncell_loc(1)
      temp1_loc(i,j,2) = temp1_loc(i,j,2)+fx(i,j)*dt*q_loc(i,j,1)
      temp1_loc(i,j,3) = temp1_loc(i,j,3)+fy(i,j)*dt*q_loc(i,j,1)
    enddo
  enddo
#endif


call bdry2d(temp1_loc)
if(nprocs .gt. 1) then
   call sendbdry2d(temp1_loc)
endif

#ifdef MHD
   call divBclean2d(q_loc,temp1_loc)
   call bdry2d(temp1_loc)
   if(nprocs .gt. 1) then
      call sendbdry2d(temp1_loc)
   endif
#endif


! RK2
call riemann2d(temp1_loc,temp1_loc,temp2_loc,1)
call riemann2d(temp1_loc,temp2_loc,temp2_loc,2)

#ifdef FORCE
  call force2d(temp1_loc,fx,fy)
  do j=1,ncell_loc(2)
    do i=1,ncell_loc(1)
      temp2_loc(i,j,2)=temp2_loc(i,j,2)+fx(i,j)*dt*temp1_loc(i,j,1)
      temp2_loc(i,j,3)=temp2_loc(i,j,3)+fy(i,j)*dt*temp1_loc(i,j,1)
    enddo
  enddo 
#endif

call bdry2d(temp2_loc)
if(nprocs .gt. 1) then
   call sendbdry2d(temp2_loc)
endif
#ifdef MHD
  call divBclean2d(temp1_loc,temp2_loc)
  call bdry2d(temp2_loc)
  if(nprocs .gt. 1) then
     call sendbdry2d(temp2_loc)
  endif
#endif

   q_loc(1:ncell_loc(1),1:ncell_loc(2),:)=0.5d0*(q_loc(1:ncell_loc(1),1:ncell_loc(2),:)+temp2_loc(1:ncell_loc(1),1:ncell_loc(2),:))

call bdry2d(q_loc)
if(nprocs .gt. 1) then
   call sendbdry2d(q_loc)
endif


if (t .ge. toutput) then
  fnum = fnum+1
  call write_collective2d(q_loc,fnum)
#ifdef GRAVITY
  call write_gravity2d(fnum)
#endif
  if(myid .eq. 0) then
     write(*,*) myid,"output data:",fnum
  endif
  if(toutput+dtout .gt. tend) then
    toutput = tend
  else
    toutput = toutput + dtout
  endif
endif


call dt_loc2d(q_loc,dt_loc)
call dt_all(dt_loc)

if(t+dt .ge. toutput) then
   dt = toutput-t
endif

if(t+dt .ge. tend) then
   dt = tend-t
endif

enddo  ! end of main loop

deallocate(x_loc)
deallocate(y_loc)
deallocate(x)
deallocate(y)
deallocate(q_loc)
deallocate(temp1_loc)
deallocate(temp2_loc)
#ifdef MHD
deallocate(temp3_loc)
#endif

#ifdef FORCE
deallocate(fx)
deallocate(fy)
#endif

#ifdef GRAVITY
deallocate(den)
deallocate(sgx)
deallocate(sgy)
deallocate(sgxker)
deallocate(sgyker)
#endif
#endif

!!!!!!!!!!!!!!!!!! 3D solver
#if NDIM==3



#endif

call MPI_FINALIZE(ierr)

end program
